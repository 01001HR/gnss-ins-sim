# -*- coding: utf-8 -*-
# Fielname = imu_sim.py

"""
SIM class.
Created on 2017-12-19
@author: dongxiaoguang
"""

import math
import numpy as np
from pathgen import pathgen
import matplotlib.pyplot as plt

D2R = math.pi/180
# built-in mobility
high_mobility = np.array([1.0, 0.5, 2.0])

class Sim(object):
    '''
    Simulation class.
    '''
    def __init__(self, fs, imu, path, ref_frame=0,\
                 mode='flight', env='2g_random', algorithm=None):
        '''
        Args:
            fs: [fs_imu, fs_gps, fs_mag], Hz
            imu:
            path: a .csv file to define the waypoints
                row 1: initial states.
                    3 initial position (LLA, deg, meter),
                    3 initial velocity in body frame(m/s),
                    3 initial attitude (Euler angles, deg)
                row >=2: motion commands.
                    col 1: motion type.
                        1: Euler angles change rate and body frame velocity change rate.
                        2: absolute att and absolute vel to rech.
                        3: relative att and vel change.
                        4: absolute att, relative vel.
                        5: relative att, absolute vel.
                    col 2-7: motion command (deg, m/s).
                        [yaw, pitch, roll, vx (velocity along body x axis), reserved, reserved].
                    col 8: maximum time for the given segment, sec.
                    col 9: reserved.
            ref_frame: reference frame used as the navigation frame,
                        0: NED (default), with x axis pointing along geographic north,
                           y axis pointing eastward,
                           z axis pointing downward.
                        1: a virtual inertial frame with constant g,
                           x axis pointing along magnetic north,
                           z axis pointing along g,
                           y axis completing a right-handed coordinate system.
            mode: simu mode could be a string to specify a built-in mode:
                    'flight':
                or a numpy array of size (3,) to customize the sim mode.
            env: vibration model.
            algorithm: a user defined algorithm.
        '''
        ########## configure simulation ##########
        self.sim_count = 1          # simulation count
        self.sim_complete = False   # simulation complete successfully
        self.imu = imu              # imu config
        # sample rate
        self.fs = Sim_data(name='fs',\
                           description='Sample frequency of imu',\
                           units=['Hz'],\
                           plottable=False)
        self.fs.data = fs[0]
        # reference frame
        self.ref_frame = Sim_data(name='ref_frame',\
                                  description='Reference frame',\
                                  plottable=False)
        if ref_frame == 0 or ref_frame == 1:
            self.ref_frame.data = ref_frame
        else:
            self.ref_frame = 0      # default frame is NED
        ########## possible data generated by simulation ##########
        # reference data
        self.time = Sim_data(name='time',\
                             description='Sample time, start from 1',\
                             units=['No. of samples'])
        self.gps_time = Sim_data(name='gps_time',\
                                 description='GPS sample time',\
                                 units=['No. of samples'])
        self.ref_pos = Sim_data(name='ref_pos',\
                                description='True pos',\
                                units=['rad', 'rad', 'm'],\
                                legend=['ref_pos_x', 'ref_pos_y', 'ref_pos_z'])
        self.ref_vel = Sim_data(name='ref_vel',\
                                description='True vel',\
                                units=['m/s', 'm/s', 'm/s'],\
                                legend=['ref_vel_x', 'ref_vel_y', 'ref_vel_z'])
        self.ref_att = Sim_data(name='ref_att',\
                                description='True attitude (Euler angles, ZYX)',\
                                units=['rad', 'rad', 'rad'],\
                                legend=['ref_Yaw', 'ref_Pitch', 'ref_Roll'])
        self.ref_gyro = Sim_data(name='ref_gyro',\
                                 description='True angular velocity',\
                                 units=['rad/s', 'rad/s', 'rad/s'],\
                                 legend=['ref_gyro_x', 'ref_gyro_y', 'ref_gyro_z'])
        self.ref_accel = Sim_data(name='ref_accel',\
                                  description='True accel',\
                                  units=['m/s2', 'm/s2', 'm/s2'],\
                                  legend=['ref_accel_x', 'ref_accel_y', 'ref_accel_z'])
        self.ref_gps = Sim_data(name='ref_gps',\
                                description='True GPS pos/vel',\
                                units=['rad', 'rad', 'm', 'm/s', 'm/s', 'm/s'],\
                                legend=['ref_gps_x', 'ref_gps_y', 'ref_gps_z',\
                                        'ref_gps_vx', 'ref_gps_vy', 'ref_gps_vz'])
                                # downsampled true pos/vel, first row is sample index,
                                # sync with self.time
        self.ref_mag = Sim_data(name='ref_mag',\
                                description='True magnetic field',\
                                units=['uT', 'uT', 'uT'],\
                                legend=['ref_mag_x', 'ref_mag_y', 'ref_mag_z'])
        # simulation results
        self.pos = Sim_data(name='pos',\
                            description='Simulation pos from algo',\
                            units=['rad', 'rad', 'm'],\
                            legend=['pos_x', 'pos_y', 'pos_z'])
        self.vel = Sim_data(name='vel',\
                            description='sim vel',\
                            units=['m/s', 'm/s', 'm/s'],\
                            legend=['vel_x', 'vel_y', 'vel_z'])
        self.att_quat = Sim_data(name='att_quat',\
                                 description='Simulation att (quaternion)  from algo',\
                                 legend=['q0', 'q1', 'q2', 'q3'])
        self.att_euler = Sim_data(name='att_euler',
                                  description='Simulation att (Euler angles, ZYX)  from algo',\
                                  units=['rad', 'rad', 'rad'],\
                                  legend=['Yaw', 'Pitch', 'Roll'])
        self.gyro = Sim_data(name='gyro',\
                             description='Gyro measurements',\
                             units=['rad/s', 'rad/s', 'rad/s'],\
                             legend=['gyro_x', 'gyro_y', 'gyro_z'])
        self.accel = Sim_data(name='accel',\
                              description='Accel measurements',\
                              units=['m/s2', 'm/s2', 'm/s2'],\
                              legend=['accel_x', 'accel_y', 'accel_z'])
        self.gps = Sim_data(name='gps',\
                            description='GPS measurements',\
                            units=['rad', 'rad', 'm', 'm/s', 'm/s', 'm/s'],\
                            legend=['gps_x', 'gps_y', 'gps_z', 'gps_vx', 'gps_vy', 'gps_vz'])
        self.mag = Sim_data(name='mag',\
                            description='Magnetometer measurements',\
                            units=['uT', 'uT', 'uT'],\
                            legend=['mag_x', 'mag_y', 'mag_z'])
        self.wb = Sim_data(name='wb',\
                           description='Gyro bias estimation',\
                           units=['rad/s', 'rad/s', 'rad/s'],\
                           legend=['gyro_bias_x', 'gyro_bias_y', 'gyro_bias_z'])
        self.ab = Sim_data(name='ab',\
                           description='Accel bias estimation',\
                           units=['m/s2', 'm/s2', 'm/s2'],\
                           legend=['accel_bias_x', 'accel_bias_y', 'accel_bias_z'])
        self.av_t = Sim_data(name='av_t',\
                             description='Allan var time',\
                             units=['s'])
        self.av_gyro = Sim_data(name='av_gyro',\
                                description='Allan var of gyro',\
                                units=['rad/s', 'rad/s', 'rad/s'],\
                                logx=True, logy=True,\
                                legend=['av_wx', 'av_wy', 'av_wz'],\
                                pre_func=np.sqrt)
        self.av_accel = Sim_data(name='av_accel',\
                                 description='Allan var of accel',\
                                 units=['m/s2', 'm/s2', 'm/s2'],\
                                 logx=True, logy=True,\
                                 legend=['av_ax', 'av_ay', 'av_az'],\
                                 pre_func=np.sqrt)

        ########## supported data ##########
        '''
        each item in the supported data should be either scalar or numpy.array of size(n, dim).
        n is the sample number, dim is a set of data at time tn. For example, accel is nx3,
        att_quat is nx4, av_t is (n,)
        '''
        # data that can be used as input to the algorithm
        '''
        There are two kinds of data that can be used as algorithm input: constant that stays the
        same for all simulations, varying that varies for different simulations.
        For example, fs stay the same for all simulations, reference data stay the same for all
        simulations, and sensor data vary for different simulations.
        '''
        self.supported_in_constant = {
            self.fs.name: self.fs,
            self.time.name: self.time,
            self.ref_frame.name: self.ref_frame,
            self.ref_pos.name: self.ref_pos,
            self.ref_vel.name: self.ref_vel,
            self.ref_att.name: self.ref_att,
            self.ref_gyro.name: self.ref_gyro,
            self.ref_accel.name: self.ref_accel}
        self.supported_in_varying = {
            self.gyro.name: self.gyro,
            self.accel.name: self.accel}
        if self.imu.gps:    # optional GPS
            self.supported_in_constant[self.ref_gps.name] = self.ref_gps
            self.supported_in_constant[self.gps_time] = self.gps_time
            self.supported_in_varying[self.gps.name] = self.gps
        if self.imu.magnetometer:   # optional mag
            self.supported_in_constant[self.ref_mag.name] = self.ref_mag
            self.supported_in_varying[self.mag.name] = self.mag
        # algorithm output that can be handled by Sim class
        # algorithm outputs vary for different simulations
        self.supported_out = {
            self.pos.name: self.pos,
            self.vel.name: self.vel,
            self.att_quat.name: self.att_quat,
            self.att_euler.name: self.att_euler,
            self.wb.name: self.wb,
            self.ab.name: self.ab,
            self.av_t.name: self.av_t,
            self.av_gyro.name: self.av_gyro,
            self.av_accel.name: self.av_accel}
        # all available data
        self.res = {}
        # all available data for plot
        self.supported_plot = {}
        # summary
        self.sum = ''

        # read motion definition
        waypoints = np.genfromtxt(path, delimiter=',')
        if waypoints.shape[0] < 2 or waypoints.shape[1] != 9:
            raise ValueError('motion definition file must have nine columns \
                              and at least two rows.')
        self.ini_pos_n = waypoints[0, 0:3]
        self.ini_pos_n[0] = self.ini_pos_n[0] * D2R
        self.ini_pos_n[1] = self.ini_pos_n[1] * D2R
        self.ini_vel_b = waypoints[0, 3:6]
        self.ini_att = waypoints[0, 6:9]
        self.motion_def = waypoints[1:, [0, 1, 2, 3, 4, 7]]
        self.motion_def[:, 1:4] = self.motion_def[:, 1:4] * D2R

        # generate GPS or not
        # output definitions
        self.output_def = np.array([[1.0, self.fs.data], [1.0, self.fs.data]])
        if self.imu.gps:
            self.output_def[1, 0] = 1.0
            self.output_def[1, 1] = fs[1]
        else:
            self.output_def[1, 0] = -1.0

        # flight mode
        if isinstance(mode, str):               # specify built-in mode
            self.mobility = high_mobility
        elif isinstance(mode, np.ndarray):      # customize the sim mode
            self.mobility = mode                # maneuver capability
        else:
            raise TypeError('mode should be a string or a numpy array of size (3,)')

        # environment-->vibraition params
        if isinstance(env, str):                # specify simple vib model
            pass
        elif isinstance(env, np.ndarray):       # customize the vib model with PSD
            pass
        else:
            raise TypeError('env should be a string or a numpy array of size (n,2)')
        self.vib_def = None

        # check algorithm
        self.algo = algorithm
        if algorithm is not None:
            self.check_algo()

    def run(self, num_times=1):
        '''
        run simulation.
        Args:
            num_times: run the simulation for num_times times with given IMU error model.
        '''
        self.sim_count = int(num_times)
        if self.sim_count < 1:
            self.sim_count = 1
        ########## generate reference data ##########
        rtn = pathgen.path_gen(np.hstack((self.ini_pos_n, self.ini_vel_b, self.ini_att)),
                               self.motion_def, self.output_def, self.mobility,
                               self.ref_frame.data, self.imu.magnetometer)
        # save reference data
        self.time.data = rtn['nav'][:, 0]
        self.ref_pos.data = rtn['nav'][:, 1:4]
        self.ref_vel.data = rtn['nav'][:, 4:7]
        self.ref_att.data = rtn['nav'][:, 7:10]
        self.ref_accel.data = rtn['imu'][:, 1:4]
        self.ref_gyro.data = rtn['imu'][:, 4:7]
        if self.imu.gps:
            self.gps_time.data = rtn['gps'][:, 0]
            self.ref_gps.data = rtn['gps'][:, 1:7]
        if self.imu.magnetometer:
            self.ref_mag.data = rtn['mag'][:, 1:4]
        ########## simulation ##########
        for i in range(0, self.sim_count):
            # generate sensor data
            self.accel.data[i] = pathgen.acc_gen(self.fs.data, self.ref_accel.data,
                                                 self.imu.accel_err, self.vib_def)
            # np.savetxt(i_str+'_accel.txt', self.accel[i])
            self.gyro.data[i] = pathgen.gyro_gen(self.fs.data, self.ref_gyro.data,\
                                                 self.imu.gyro_err)
            # np.savetxt(i_str+'_gyro.txt', self.gyro[i])
            if self.imu.gps:
                self.gps.data[i] = pathgen.gps_gen(self.ref_gps.data, self.imu.gps_err,\
                                                   self.ref_frame.data)
                # np.savetxt(i_str+'_gps.txt', self.gps[i])
            if self.imu.magnetometer:
                self.mag.data[i] = pathgen.mag_gen(self.ref_mag.data, self.imu.mag_err)
                # np.savetxt(i_str+'_mag.txt', self.mag[i])
            # run specified algorithm
            if self.algo is not None:
                # input
                algo_input = []
                for j in self.algo.input:
                    if j in self.supported_in_constant:
                        algo_input.append(self.supported_in_constant[j].data)
                    else:
                        algo_input.append(self.supported_in_varying[j].data[i])
                # run
                self.algo.run(algo_input)
                # output
                nout = len(self.algo.output)
                algo_results = self.algo.get_results()
                for j in range(nout):
                    self.supported_out[self.algo.output[j]].data[i] = algo_results[j]
                # reset algorithm for next run
                self.algo.reset()
        # simulation complete successfully
        self.sim_complete = True

    def results(self, data_dir=None):
        '''
        simulation results.
        Returns: a dict contains all simulation results.
        '''
        if self.sim_complete:
            '''
            generate a dict to tell what simulation results can be acquired, and what results
            can be plotted.
            '''
            # data from pathgen are available after simulation
            self.res = self.supported_in_constant.copy()
            self.res.update(self.supported_in_varying)
            # add user specified algorithm output to results
            if self.algo is not None:
                for i in self.algo.output:
                    self.res[i] = self.supported_out[i]
            # generate supported plot
            self.supported_plot = self.res.copy()
            self.supported_plot.pop('fs')
            self.supported_plot.pop('ref_frame')
            # print(self.res)
            # print(self.supported_plot)
            '''
            Save results to file.
            Simulation results include a summary file containing statistics of the simulation
            and .csv files containing all data generated.
            '''
            if data_dir is not None:    # save to files
                import os
                import time
                # check data dir
                if not os.path.exists(data_dir):
                    data_dir = os.path.abspath('.//data//')
                else:
                    data_dir = os.path.abspath(data_dir)
                if data_dir[-1] != '//':
                    data_dir = data_dir + '//'
                data_dir = data_dir + time.strftime('%Y-%m-%d-%H-%M-%S', time.localtime()) + '//'
                if not os.path.exists(data_dir):
                    os.makedirs(data_dir)
                # save summary
                self.summary()  # generate summary
                try:
                    with open(data_dir + '//summary.txt', 'w') as file_summary:
                        file_summary.write(self.sum + '\n')
                except:
                    raise IOError('Unable to save summary to %s.'% data_dir)
                # save data
                for i in self.supported_plot:
                    self.supported_plot[i].save_to_file(data_dir)
        return self.res

    def summary(self):
        '''
        Summary of sim results.
        '''
        #### simulation config
        # sample frequency
        self.sum += self.fs.description + ': [' +\
                    self.fs.name + '] = ' +\
                    str(self.fs.data) + ' ' +\
                    self.fs.units[0] + '\n'
        # simulation time duration
        self.sum += 'Simulation time duration: ' + \
                    str(self.time.data[-1] / self.fs.data) + ' s' + '\n'

    def check_algo(self):
        '''
        Generate expressions to handle algorithm input and output.
        Args:
            algorithm: user specified algorithm class
        Returns:
            Raise ValueError if algorithm has no input or output;
            Raise ValueError if algorithm input and output have unsupported elements
            Raise TypeError if algorithm input or output is not a list or tuple
        '''
        try:
            n_in = len(self.algo.input)
            n_out = len(self.algo.output)
            # algorithm must have at least one input and one output
            if n_in < 1 or n_out < 1:
                raise ValueError
            # prepare algorithm input and output
            for i in self.algo.input:
                if not i in self.supported_in_constant and not i in self.supported_in_varying:
                    raise ValueError
            for i in self.algo.output:
                if not i in self.supported_out:
                    raise ValueError
        except ValueError:
            raise ValueError('check input and output definitions of the algorithm.')
        except:
            raise TypeError('algorithm input or output is not a valid list or tuple.')

    def plot(self, what_to_plot, sim_idx=None):
        '''
        Plot specified results.
        Args:
            what_to_plot: a string list to specify what to plot. See manual for details.
            sim_idx: specify the simulation index. This can be an integer, or a list or tuple.
                Each element should be within [0, num_times-1]. Default is None, and plot data
                of all simulations.
        '''
        # check sim_idx
        if sim_idx is None:                 # no index specified, plot all data
            sim_idx = list(range(self.sim_count))
        elif isinstance(sim_idx, int):      # scalar input, convert to list
            sim_idx = [sim_idx]
        elif isinstance(sim_idx, float):
            sim_idx = [int(sim_idx)]
        invalid_idx = []
        for i in range(0, len(sim_idx)):    # a list specified, remove invalid values
            sim_idx[i] = int(sim_idx[i])
            if sim_idx[i] >= self.sim_count or sim_idx[i] < 0:
                invalid_idx.append(sim_idx[i])
                print('sim_idx[%s] = %s exceeds max simulation count: %s.'%\
                      (i, sim_idx[i], self.sim_count))
        for i in invalid_idx:
            sim_idx.remove(i)
        # dict of data to plot
        for i in what_to_plot:
            # print("data to plot: %s"% i)
            x_axis = self.time
            if i in self.supported_plot:
                if i in self.supported_in_constant:
                    if i == self.ref_gps.name or i == self.gps_time.name:
                        x_axis = self.gps_time
                    self.supported_plot[i].plot(x_axis)
                else:
                    if i == self.av_gyro.name or i == self.av_accel.name or i == self.av_t.name:
                        x_axis = self.av_t
                    elif i == self.gps.name:
                        x_axis = self.gps_time
                    self.supported_plot[i].plot(x_axis, sim_idx)
            else:
                print('Unsupported plot: %s.'% i)
                # print("Only the following data are available for plot:")
                # print(list(self.supported_plot.keys()))
                # raise ValueError("Unsupported data to plot: %s."%data)
        # show figures
        plt.show()

class Sim_data(object):
    '''
    Simulation data
    '''
    def __init__(self, name, description, units=None,\
                 plottable=True, logx=False, logy=False,\
                 grid='on', legend=None, pre_func=None):
        '''
        Set up data properties and plot properties. All data are stored in a dict: self.data.
        Each key of this dict corresponds to a set of data. self.data[key] is of size mxn.
        m is the number of samples of this set of data. n is the dimension of this set of data.
        m may vary through different set of data. n must be same for all sets of data.
        Args:
            name: string name of the data
            description: string description of the data
            units: a tuple or list of strings to specify units of data.
                The length of units is the same as columns of each set of data in self.data.
            logx: plot this data with log scaling on x axis
            logy: plot this data with log scaling on y axis
            grid: if this is not 'off', it will be changed to 'on'
            legend: tuple or list of strings to specify legend of data.
                The length of units is the same as columns of each set of data in self.data.
        '''
        self.name = name
        self.description = description
        self.units = units
        if self.units is None:
            self.units = []
        self.plottable = plottable
        self.logx = logx
        self.logy = logy
        self.grid = 'on'
        if grid.lower() == 'off':
            self.grid = grid
        self.legend = legend
        self.pre_func = pre_func
        # a dict to store data, each key corresponds to a set of data
        # or a numpy array of size(m,n)
        # or a scalar
        self.data = {}

    def plot(self, x, key=None):
        '''
        Plot self.data[key]
        Args:
            key is a tuple or list of keys
            x: x axis data
        '''
        if self.plottable:
            if isinstance(self.data, dict):
                self.plot_dict(x, key)
            else:
                self.plot_array(x)

    def plot_dict(self, x, key):
        '''
        self.data is a dict. plot self.data according to key
        '''
        for i in key:
            if self.pre_func is not None:
                y_data = self.pre_func(self.data[i])
            else:
                y_data = self.data[i]
            if isinstance(x.data, dict):
                x_data = x.data[i]
            else:
                x_data = x.data
            plot_in_one_figure(x_data, y_data,\
                               logx=self.logx, logy=self.logy,\
                               title=self.name + '_' + str(i),\
                               xlabel=x.name + ' (' + x.units[0] + ')',\
                               ylabel=self.name + ' (' + str(self.units) + ')',\
                               grid=self.grid,\
                               legend=self.legend)

    def plot_array(self, x):
        '''
        self.data is a numpy.array
        '''
        if isinstance(x.data, dict):
            x_data = x.data[0]
        else:
            x_data = x.data
        plot_in_one_figure(x_data, self.data,\
                           logx=self.logx, logy=self.logy,\
                           xlabel=x.name + ' (' + x.units[0] + ')',\
                           ylabel=self.name + ' (' + str(self.units) + ')',\
                           title=self.name,\
                           grid=self.grid,\
                           legend=self.legend)

    def save_to_file(self, data_dir):
        '''
        Save self.data to files.
        Args:
            data_dir: directory for the data files.
        '''
        #### generate header
        # how many columns in each set of data? 0 if scalar
        cols = 0
        if isinstance(self.data, dict):
            for i in self.data.keys():
                if self.data[i].ndim > 1:
                    cols = self.data[i].shape[1]
                break   # each set of data in data should have the same number of columns
        else:
            if self.data.ndim > 1:
                cols = self.data.shape[1]
        # add the name and unit of each column to header
        header_line = ''
        if cols > 0:    # more than one column
            for i in range(cols):
                # units
                str_unit = ''
                if i < len(self.units):
                    str_unit = ' (' + self.units[i] + ')'
                # add a column
                if cols == len(self.legend):    # legend available
                    header_line += self.legend[i] + str_unit + ','
                else:                           # legend not available
                    header_line += self.name + '_' + str(i) + str_unit + ','
            # remove the trailing ','
            header_line = header_line[0:-1]
        else:           # only one column
            str_unit = ''
            if len(self.units) > 0:
                str_unit = ' (' + self.units[0] + ')'
            header_line = self.name + str_unit
        #### save data and header to .csv files
        if isinstance(self.data, dict):
            for i in self.data:
                file_name = data_dir + '//' + self.name + '_' + str(i) + '.csv'
                np.savetxt(file_name, self.data[i], header=header_line, delimiter=',', comments='')
        else:
            file_name = data_dir + '//' + self.name + '.csv'
            np.savetxt(file_name, self.data, header=header_line, delimiter=',', comments='')

def plot_in_one_figure(x, y, logx=False, logy=False,\
                       title='Figure', xlabel=None, ylabel=None,\
                       grid='on', legend=None):
    '''
    Create a figure and plot x/y in this figure.
    Args:
        x: x axis data, np.array of size (n,) or (n,1)
        y: y axis data, np.array of size (n,dim)
        title: figure title
        gird: if this is not 'off', it will be changed to 'on'
        legend: tuple or list of strings of length dim.
    '''
    # create figure and axis
    fig = plt.figure(title)
    axis = fig.add_subplot(111)
    lines = []
    try:
        dim = y.ndim
        if dim == 1:
            if logx and logy:   # loglog
                line, = axis.loglog(x, y)
            elif logx:          # semilogx
                line, = axis.semilogx(x, y)
            elif logy:          # semilogy
                line, = axis.semilogy(x, y)
            else:               # plot
                line, = axis.plot(x, y)
            lines.append(line)
        elif dim == 2:
            for i in range(0, y.shape[1]):
                if logx and logy:   # loglog
                    line, = axis.loglog(x, y[:, i])
                elif logx:          # semilogx
                    line, = axis.semilogx(x, y[:, i])
                elif logy:          # semilogy
                    line, = axis.semilogy(x, y[:, i])
                else:               # plot
                    line, = axis.plot(x, y[:, i])
                lines.append(line)
        else:
            raise ValueError
    except:
        print(x.shape)
        print(y.shape)
        raise ValueError('Check input data y.')
    # label
    if xlabel is not None:
        plt.xlabel(xlabel)
    if ylabel is not None:
        plt.ylabel(ylabel)
    # legend
    if legend is not None:
        plt.legend(lines, legend)
    # grid
    if grid.lower() != 'off':
        plt.grid()
